---
title: "Class 3"
author: "Pernille Brams"
date: "22/2/2024"
output:
  html_document:
    toc: true  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Setting my root directory to where I have my /data folder etc. (easier for me, but personalise to your own way of working)
knitr::opts_knit$set(root.dir = "/Users/mie/OneDrive/Skole/Methods 2 The General Linear Model/Methods2_resources/classes")

```

```{r libs}
library(pacman)

pacman::p_load(tidyverse,
               ggpubr,
               ggplot2)

```


```{r livecoding}

# *add baseline distribution from Pernille's slides - probability density function*

      # law of large numbers - the more datapoints, the close the distribution of the data will come to the population distribution

# - - - - - - - - -


# for loop that squares the numbers from 1:16

for (i in 1:16){
  squaredNumber <- i^2        # i could have also been called 'number' for readability
  print(squaredNumber)

} # figure out why this is weird, it should print each time - okay so okay no beautifying or be careful about the indents!!! or maybe it actually doesn not want beautification *look thru recent r code for this - e.g. class 2, portfolio and such*








# while loops 

counter <- 1

while(counter <= 25){
  
  print(paste("Counter is currently: ", counter)) # paste() lets us combine strings and non-string variables
  
  counter = counter + 1
  
  }





# if-else statements - checking if a number is pos, neg or 0

numb <- 9



if(numb > 0){
  
  print("positive number")
  
  } else if(numb < 0){

  print("negative number")
    
  } else{
    
  print("number is zero")
    
  }



## ey beautification worked 
if(numb > 0)
  {
  
  print("positive number")
  
  } else if(numb < 0)
    {

  print("negative number")
    
  } else
    {
    
  print("number is zero")
    
  }






# if-else statement in a for loop

list_of_numbers <- c(9,-5,6,3242342,0)

for(number in list_of_numbers){
  #*insert if-statements from above*
}





# if-else statement in a function

numberChecker <- function(list_of_numbers){
  #*insert for loop from above*  
}


numberChecker(c(3,4,8,-2,2,0.1,0))



# - - - - -

# function calculating the area of a rectangle

# as length is a function name is good to not make that name a variable

areaRec <- function(width, length_){
  area <- width * length_
  
  return(area)
  
  
}


areaRec(2,2)









```



# Continuing learning about simulations (and practicing a bit)
In coding, repetition is key when learning it... (at least it is for me) - it's kind of like when you learn a new language :333 n'est pas??

Choose your exercises as per your needs - all of this is highly relevant for the remaining portfolios and exercises. In a few weeks, you'll get the opportunity (only if you want to) to submit answers to some exercises I'll give you (including some like the ones below) to me, and I'll review them and give you feedback.

Also, never feel 'guilty' for using hints / ask for help. Hints are there and we are there to help out. Try first on your own, and use the hint/ask when you feel your working memory slacking a bit :)) Just make sure you have some idea about what's going on in the code, also after you've used the hint.

## A. Need some more practice in for loops?
### A1 Using a for-loop, calculate the sum of the first 100 positive integers, starting from 1
Result to check: You should get 5050.

Hint A1* under Hints
```{r}

# sets the result to 0 before start
result = 0

# loop adding the number from 1 to 100 to the result one at a time
for (i in 1:100) {
  result = result + i
  
}

print(result) # printing the result



```

### A2 Using a for-loop, create a vector of the squares of the first 20 positive integers, starting from 1. Calculate the sum of the vector.
Result to check: You should get 2870.

Hint A2* under Hints
```{r}

# makes the vector before start of loop
vectorA2 = c()

# loop adding the number from 1 to 20 squared to the vector one at a time
for (i in 1:20) {
  vectorA2 =  append(vectorA2, i^2)
  
}

print(vectorA2) # printing the resulting vector


print(sum(vectorA2)) # prints the sum of the resulting vector


```

## B. Need some more practice in while loops? 
### B1 Use a while loop to find the smallest integer n, such that the sum of the first n positive integers is greater than 1000.
Result to check: You should get 45 here

Hint B1* under Hints

```{r}

# dont get what i'm exactly asked to do here






```



### B2 Create a countdown from 10 to 1 and then print "Lift off!".

Hint B2* under Hints

```{r}

countdown = TRUE

while(countdown == TRUE){
  
  for(i in 10:1){
    print(i) # prints the count down
  }
  
  print("Lift off!")
  
  countdown = FALSE

}




```

## C. Need some more practice in if-else statement? 
### C1 Write code to determine if a given integer x is positive, negative, or zero, for the following values for x: 
-4
7
23
-120309
0

```{r}

# done during today's live coding


```

Tip for C1: do it one by one first, and if you need more practice, do a for-loop and check them that way.

### C2 Write a script that categorizes a person's age: child (< 12), teenager (12-18), adult (19-65), senior (> 65) for the following ages
Ages: 
10
20
56
19
89
:) :) 26 <3 <3 

```{r}

ages = c(10, 20, 56, 19, 89, 26)

ageCategorization = c()


for(specificAge in 1:length(ages))
  {
   if(ages[specificAge] < 12 && ages[specificAge] >= 0)
     {
      categorization = "child"
     
      ageCategorization = append(ageCategorization, categorization)
      
     } else if(ages[specificAge] >= 12 && ages[specificAge] <= 18)
      {

      categorization = "teenager"
     
      ageCategorization = append(ageCategorization, categorization)
       
      
     } else if(ages[specificAge] >= 19 && ages[specificAge] <= 65)
      {

      categorization = "adult"
     
      ageCategorization = append(ageCategorization, categorization)
       
     } else if(ages[specificAge] > 65)
      {

      categorization = "senior"
     
      ageCategorization = append(ageCategorization, categorization)
       
     } #should i add an 'else'

  
  }


print(ageCategorization) # printing the resulting vector of the categorisations of people's ages



```

## D. Need some more practice in functions? 
### D1 Create a function that takes a vector of numbers and returns the mean of that vector.
(If you need to, check class 2's doc for how to write functions)
```{r}

numbVec = c(10, 20, 56, 19, 89, 26)



vecMean <- function(numbVector){
  
  sumVec = sum(numbVector)
  
  meanVec = sumVec/length(numbVector)
  
  return(meanVec)
  
}


print( vecMean(numbVec) ) # calls the function to get the mean of the vector numbVec


```

### D2 Write a function named calculate_area_circle that takes the radius of a circle as its argument and returns the area of the circle. Remember, the formula to calculate the area of a circle is pi*r^2, where r is the radius of the circle.

```{r}


calculate_area_circle <- function(radius){
  
  areaCircle = radius^2 * pi
  
  return(areaCircle)
  
}


print( calculate_area_circle(3) ) # calls the function to get the area of a circle with the radius of (in this case) 3




```

## E. Need some more practice in simulations? 
### E1 Write a simulation to mimic the rolling of two six-sided dice. Simulate rolling the two dice 10000 times and store the sum of the dice faces for each roll. Plot a histogram of the sums to see the distribution of the total dice rolls. Calculate and print the mean and standard deviation of the rolls.
```{r}

# resets list used for the rolling of the 2 six-sided dice
simulationData <- list()


# function simulating the rolling of the 2 six-sided dice and returning the results of such a roll
diceRolls = function(){
  
  simulatedRolls <- sample(1:6, size = 2, replace = TRUE) # 1:6 specifying the possible views, 2 the number of items to choose, replace = true means that the same outcomes can be picked again (with replacement)
  
  simulationData <- unlist( append(simulationData, simulatedRolls) )
  
  simulationData_sum <- sum(simulationData)
  
  simulationData_sd <- sd(simulationData)
  
  #print(sd(simulationData))
  
  
  return(c(simulationData_sum, simulationData_sd))
  
}


# resets list for which to use for the 10000 simulations of the rolls of 2 six-sided dice
diceRolls_sum <- list()
diceRolls_sd <- list()

# for loop simulating 10000 rolls of these 2 dice
for(i in 1:10000){
  
  diceRolls_data <- diceRolls()
  
  # sum
  diceRolls_sum[i] <- diceRolls_data[1]
  
  
  # sd
  diceRolls_sd[i] <-  diceRolls_data[2]
  
  
}


# - - - - - - 

# plots the histogram of the sum of the simulated roll of 2 six-sided dice
hist(unlist( diceRolls_sum ), main = "Distribution of Sum of rolls of 2 six-sided dice", xlab = "Sum of 2 dice rolls", ylab = "Frequency")

# - - - - - - 

# prints the  mean and standard deviation of the rolls

print(unlist( diceRolls_sum )) # prints the resulting list with the results of the sum from each of the simulated roll of 2 six-sided dice

print(unlist( diceRolls_sd )) # prints the resulting list with the results of the sd from each of the simulated roll of 2 six-sided dice


```

### E2 Consider a population that grows exponentially according to the formula \(P = P_0e^{rt}\) (the e^{rt} part is written exp(r*t) in r), where \(P_0\) is the initial population size, \(r\) is the rate of growth, and \(t\) is time in years. Simulate the growth of a population starting with 100 individuals and a growth rate of 2% per year over 50 years. Plot the population size each year.

```{r}

## declaring variables
p0 <- 100 # starting point of individuals in the population
rateGrowth <- 1.02 # rate of growth

yearsInterest <- 50 # years of interest

# makes a list for populations for each year from 1 to 50, which is later made into a dictionary with each index being the year of the population size
populationYear <- list()



for (year in 1:yearsInterest) {
  population_growth <- p0 * exp(rateGrowth * year)
  
  populationYear[[as.character(year)]] = round( population_growth, 1)
  
}


names(populationYear) <- 1:yearsInterest # makes populationYear a dictionary by naming the elements by their corresponding year


print(populationYear)





```

### E3 Simulate the annual returns of an investment portfolio with an average return of 7% and a standard deviation of 10%. Assume the returns follow a normal distribution. Simulate 30 years of returns and calculate the final portfolio value assuming an initial investment of $10,000. Repeat this simulation 1000 times and plot a histogram of the final portfolio values. Calculate the mean and standard deviation of the final values.

```{r}

# function needs to return the finial portfolio value after 30 years - which would been adding the return from each year right?


## declaring variables
return_average <- 0.07 # average return
return_sd <- 0.1 # standard deviation of return average

years <- 30


# resets list used for the rolling of the 2 six-sided dice
simulationData <- list()


# function simulating the rolling of the 2 six-sided dice and returning the results of such a roll
investmentReturns = function(initialInvestment){
  
  
  simulatedReturns <- rnorm(n = years, mean = return_average, sd = return_sd) # the simulated returns for 30 years
  
  simulationData <- unlist( append(simulationData, simulatedReturns) )
  
  investment <- initialInvestment
  
  
  for(year in 1:years){
    
    investment <- investment * (1 + simulatedReturns[year]) # adds the final portfolio value for each year
    
  }
  
  finialPortfolioValue <- investment
  
  
  return(finialPortfolioValue)
  
}





finialPortfolioValue_data <- list()
finialPortfolioValue_sim <- list()
  
# for loop simulating 1000 cases of final return values after 30 years
for(i in 1:1000){
  
  #print(finialPortfolioValue_sim)
  
  finialPortfolioValue_data <- investmentReturns(10000) # stores the finial portfolio value for each simulation
  
  finialPortfolioValue_sim <- c(finialPortfolioValue_sim, finialPortfolioValue_data) # combines the finial portfolio value for each simulation into one list (which does become a list of list, but that it "fixed" in the next line)
  
  
  #print(unlist (finialPortfolioValue_sim ) )
  
  
  
}

finialPortfolioValue_sim <- unlist( finialPortfolioValue_sim )

finialPortfolioValue_sim


# - - - - - - 

# plots the histogram of the sum of the simulated roll of 2 six-sided dice
hist(finialPortfolioValue_sim, breaks = 20, main = "Distribution of final portfolio value after 30 years", xlab = "Final Portfolio Value", ylab = "Frequency")


# - - - - - - 

# calculate the mean and standard deviation of the final values

paste("the mean of the final values are: ", round( mean(finialPortfolioValue_sim), 2)) # mean

paste("the sd of the final values are: ", round( sd(finialPortfolioValue_sim), 2)) # sd


```

# do this, E4

#### E4 (Ex. 3.5 from the book) Probability distributions: Using a bar plot in R, graph the binomial distribution with n = 20 and p = 0.3.

```{r}

E4_xAxis <- rbinom(n = 20, 100, prob = 0.3)  # generates random numbers from a binomial distribution; simulating the number of successes
E4_xAxis


E4_xAxis <- dbinom(0:20, size = 20, prob = 0.3)  # calculates the probability mass function (PMF) of the binomial distribution; that is the prob of getting a specific number 
E4_xAxis

# - - - - - - 


## both of the above could in theory be meant by the task description, but the book usually means simulating when saying graphing so most likely it refers to the first option


# plots the barplot
barplot(E4_xAxis, main = "Distribution of data simulated from the binomial distribution", xlab = "Binomial distribution", ylab = "Frequency")





```

### E5 Sampling from a discrete distribution - rolling a loaded die
A loaded (or biased) die is one where the probabilities of landing on each number are not equal. Simulate rolling a loaded die 10,000 times, where the probabilities of rolling each number from 1 to 6 are given as follows: P(1) = 0.05, P(2) = 0.10, P(3) = 0.35, P(4) = 0.25, P(5) = 0.15, P(6) = 0.10. Plot a histogram of the outcomes and calculate the mean and standard deviation of the results.

```{r}

## inspired by the book example of girls (+ also for twins) born

loadedDieRolls <- sample( x = c(1, 2, 3, 4, 5, 6), size = 10000, replace = TRUE, prob = c(0.05, 0.1, 0.35, 0.25, 0.15, 0.1) ) # kombinatorik - with replacement; specifying x = the values to chose from,  size = the number of items to chose/give a value,  replace = a value once used can be used again,  prob = the probabiliy of the various x-values


# - - - - - - 


# plots the histogram of the results from rolling this loaded die
hist(loadedDieRolls, breaks = 0:6, main = "Distribution of rolls of a loaded die", xlab = "Result of die roll (1-6)", ylab = "Frequency")


```

### E6 Sampling from a continuous distribution - generating heights
Assume that the heights of individuals in a population are normally distributed with a mean of 170 cm and a standard deviation of 10 cm. Generate a sample of 1,000 individual heights from this distribution. Plot a histogram of the generated heights and calculate the mean and standard deviation of the sample.

```{r}

simulatedHeights <- rnorm(n = 1000, mean = 170, sd = 10) # generated sample of 1000 heights from the normally distributed heights of the population



# - - - - - - 


# plots the histogram of the generated sample of heights normally distributed
hist(simulatedHeights, main = "Normal distribution of individual heights", xlab = "Heights (cm)", ylab = "Frequency")






```

### E7 Simulating coin flips - Bernoulli Distribution
(this is something we work with on the master's hehe)

Simulate flipping a fair coin 5,000 times, where the outcome of each flip is either "Heads" or "Tails" with equal probability. Calculate and print the proportion of flips that result in Heads. This exercise demonstrates sampling from a Bernoulli distribution, which is a simple case of a discrete distribution.
```{r}


## makes a list of the 5000 trials storing whether it resulted in a heads of tails
fairCoin_toss <- sample( x = c("heads", "tails"), size = 5000, replace = TRUE, prob = c(0.5, 0.5) ) # kombinatorik - with replacement; specifying x = the values to chose from,  size = the number of items to chose/give a value,  replace = a value once used can be used again,  prob = the probabiliy of the various x-values

table(fairCoin_toss) # counting the number of each unique value


# or....

# counts the number of either heads or tails (in this case, we pick heads) out of the 5000 trails - the better for this specific task
fairCoin_toss <- rbinom(n = 1, size = 5000, prob = 0.5)  # generates random numbers from a binomial distribution; simulating the number of successes

paste( "this is the proportion of heads in 5000 trials: ", fairCoin_toss)




```

# A few more exercises from the book
## Chapter 3
#### Ex 3.3 Probability distributions: Using R, graph probability densities for the normal distribution, plotting several different curves corresponding to different choices of mean and standard deviation parameters.
A note: The task is to draw/plot some probability distributions for the normal distribution. From Methods 1 we learnt the normal distribution as just one thing that we want to compare our data against to e.g. check for normality of residuals. Actually, the normal distribution (also known as the gaussian) is also called family of distributions that can have any real value as the mean and any positive value as the standard deviation. The *standard* normal distribution is a special case of the normal distribution with a mean of 0 and standard deviation of 1, and this guy we know from Methods 1.

The point of this task is thus for you to see what happens when you vary the mean/standard deviation and nothing else in a distribution.
```{r}

for(i in 1:20){
  
  mean_rand <- rnorm(1)
  sd_rand <- rnorm(1)
  
  
  
  simualtedNormalDistribution <- rnorm(n = 1000, mean = mean_rand, sd = abs( sd_rand )) # random values are created from the normal distribution this wasn't part of the task


  # plots the different simulations - really the task is only asking for the red line, but i thought the blue from the simulations might be a nice added addition
  plotting <- ggplot(data.frame(x = simualtedNormalDistribution), aes(x)) +  geom_histogram(aes(y = ..density..), bins = 30, fill = "skyblue", color = "black") + stat_function(fun = dnorm, args = list(mean = mean(simualtedNormalDistribution), sd = sd(simualtedNormalDistribution)), color = "red") + labs(title = "Histogram of Simulated Normal distributions", x = "Value", y = "Density", subtitle = paste("mean = ", round( mean_rand, 3), " and sd = ", round( abs( sd_rand ), 3)))
  
  print(plotting)
  
}




```

#### Ex. 3.4 Probability distributions: Using a bar plot in R, graph the Poisson distribution with parameter 3.5.
(Remember when the book says 'graph' it means simulate some data as per instructions and make a plot)

```{r}

poissonDistribution <-rpois(n = 20, 3.5)	




# plots the barplot
barplot(poissonDistribution, main = "Distribution of data simulated from the poisson distribution", xlab = "Poisson distribution", ylab = "Frequency")

# ?



```

# Hints for exercises A-E
## Hints for A
Hint A1: Start by making a variable called my_sum (or whatever you want to call it), starting at 0. Can you write code to loop through from i = 1 all the way to 100 and add each i to 'my_sum'? 

Hint A2: Create an empty vector (or a vector full of 0s or something) that's as long as you need it to be. Then in your for loop, use indexing in your vector to place your squared values. After the for loop has run, you can just do sum(your_vector_with_the_squared_values). 

## Hints for B
Hint B1: Start by defining a sum-tracker object, which will be used in the loop to check if it is below/equal to 1000 - because while (!) that is true, we want to add the next number to the sum-tracker. The while loop will stop when the condition youve set ISNT true anymore, and then, you should print the n it got to (so you also need to, before your while loop starts, define an n, which is the positive integer-holder).

Hint B2: For this loop, you're gonna be counting down, so subtracting something from an object you must define, and subtracting until 0. So your 'while' statement has to be like "while this object is OVER 0".
