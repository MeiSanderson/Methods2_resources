---
title: "Week 2"
author: "Pernille Brams feat. Kathrine Schultz-Nielsen"
date: "22/2/2024"
output:
  html_document:
    toc: true  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Setting my root directory to where I have my /data folder etc. (easier for me, but personalise to your own way of working)
knitr::opts_knit$set(root.dir = "/Users/mie/OneDrive/Skole/Methods 2 The General Linear Model/Methods2_resources/classes")

```

```{r libs}
library(pacman)

pacman::p_load(tidyverse,
               ggpubr,
               ggplot2)

```


```{r live coding from class - done together}

pacman::p_load(tidyverse,
               ggplot2)


## learning functions - try making a function

minFunc <- function(parameter1, parameter2)
  {
  value <- parameter1 * 2 - parameter2
  
  return(value)
  
  }


minFunc(1,0)


# ----------------------------------------------- # shift + ctrl + a = beautifies the code by spaces (!!!)


## learning functions - try making a function with normal distribution and plotting, f1

# initial parameters
 #mu <- 0
 #sigma <- 1
 #tau <- 1
 

# the functions

f1 <- function(xValues, mu, sigma)
{
  f1 <- (1 / (sigma * sqrt(2 * pi))) * exp(1) ^ (-0.5 * ((x - mean) / sigma)^2) # you have this in the code from yesterday - check that
  
  f1 <- (1 / (sigma * sqrt(2 * pi))) * exp(-0.5 * ((x - mean) / sigma)^2)
  
  return(f1)
  
}

f2 <- function(xValues, mu, tau)
{
  f2 <- sqrt(tau/(2*pi))*exp((-tau*(x-mean)^2)/2)
  
  return(f2)
  
}



# generate x values

xValues <- seq(-5, 5, 0.1) #0.1 is increments*




# calculate y-values from the functions f_1 and f_2

y_f1 <- f1(xValues)

y_f2 <- f2(xValues)



# make dataframe for plotting

dataframe <- data.frame(x = xValues,
                        f1 = y_f1,
                        f2 = y_f2)


# plotting

plot1 <- ggplot(dataframe,
                aes(x))+
  geom_line(aes(y = f1, colour = "f1"))+
  geom_line(aes(y = f2, colour = "f2"))+
  labs(title = "hello")+
  theme_minimal()

plot1



## why are the plotted functions the same when 2 different functions have been used IF sigma & tau = 1

    # sqrt(1/t) = sd -> the relationship between them

      # sqrt(1/1) = sd -> 1 = sd -> which matches with our hardcoding of sd as 1


## new parameters

y_f1_new <- f1(xValues, mu = 0, sigma = 3)

y_f2_ew <- f2(xValues, mu = 0, tau = 3)



## why are the plotted functions then different when 2 different functions have been used IF sigma (sd) & tau = 3 (precision)

      # f2 with tau (precision) - the higher value of tau, the more precise, the smaller the width

      # f1 with sigma (sd) - the lower the value of sigma, the more precise, the smaller the width








### confusion Hi

t = 2
mean = 7
x = 8.4

part1_2 <- sqrt(t/(2*pi))

part2_2 <- (-t*(x-mean)^2)/2

f2 <- part1_2*exp(1)^(part2_2)

f2



```






# Learning about for loops, if-else statements, functions - and practicing simulating!
(Lots of stuff in chapter 4-5 about this)

Loops can be good for simulating. And they are cool. Let's practice is a bit.

## Exercises to practise loops (discuss with partner/group if you want to)
### Ex. A: What is the difference between a for- and a while loop? Explain in your own words in 1-2 sentences.

  a for loop runs a chunk of code for every i in something.   e.g. for every i out of 10 by i++
  
  a while loop runs a chunk while something remains true      e.g. if x == T, then the code chunk runs


### Ex. B: When would you use for-loops and when would you use while-loops? Explain in your own words in 1-2 sentences

  when some code has to be run a specific number of times.            e.g. often if x = x + 1
  
  when some code has to keep running until something becomes false    e.g. ***



### Ex. C: Create and run both a simple for and a while loop
I've made an example below. Make your own example below it. If you have no ideas for what to code in your for loop, here's an example you can try to code up:
- A simple for loop could be for each i in 1:20, print i if i is above 3
```{r}
# Here's a simple for-loop
for (i in 1:10){ # For each i in 1:10...
  print(i+5)    # Do this..
}




# your simple loop here

for (i in 1:20)
{
  if(i > 3)
  {
    print(i)
  }
}


```

I've also made an example of a while loop below. Make your own example below it. If you have no ideas for what to code in your while loop, here's an example you can try to code up:
- A simple while loop could be while some_number is below 20, print("the number is below 20, so I still run! (until it isn't true anymore)". Each time it 'checks' make sure to add some number to the some_number - could be 7
```{r}
# A simple while-loop
number = 0
while (number < 10){ # While the number is below 10, do the following
  print(number)
  number = number + 1
}





# your simple while-loop here

hungry = TRUE
iceCreamEaten = 0

while(hungry == TRUE)
{
  iceCreamEaten = iceCreamEaten + 1
  
  if (iceCreamEaten >= 3)
  {
    hungry = FALSE
    
    print(iceCreamEaten)
  }
  
}


```

## Exercises to practise functions and if-else statements
### Ex. D: Write a function in R that converts temperature from Fahrenheit to Celsius.
Create a function that accepts a temperature in Fahrenheit and returns the temperature converted to Celsius. The formula to convert Fahrenheit to Celsius is: C = (F-32)*5/9.
```{r}
# Function to convert Fahrenheit to Celsius
convert_to_celsius <- function(fahrenheit) 
  {
    celsius <- ((fahrenheit - 32) * 5) / 9
    
    return(celsius)
    
}


# tests that the function works - Expected Output (for fahrenheit = 68): 20
convert_to_celsius(68)





###Pernille comments:
  # Hint: Apply the conversion formula within the function



# Example of how the final function (when you've written it) should be used:
# temp_celsius <- convert_to_celsius(68)
# print(temp_celsius)
# Expected Output (for fahrenheit = 68): 20
```

### Ex. E: Write a function in R that provides clothing advice based on the temperature:
Create a function that accepts the current temperature (in Celsius) as an argument and returns advice on what type of clothing to wear. The function should use if-else statements to determine the appropriate clothing advice.

Here's the advice that your function should give based on the conditions:

If the temperature is above 25 degrees Celsius, suggest wearing a T-shirt.
If the temperature is between 15 and 25 degrees (inclusive), suggest wearing a light jacket.
If the temperature is below 15 degrees, suggest wearing a warm coat.

Use statements if, else if, and else. Google how to set up the syntax with curly brackets and so on if you're not sure.
```{r}
# Function to give clothing advice based on temperature
clothing_advice <- function(temperature)
{
    if (temperature > 25)
    {
      print("Suggestion: wear a T-shirt")
    }
    else if (temperature >= 15 && temperature <= 25)
    {
      print("Suggestion: wear a light jacket")
    }
    else if (temperature < 15)
    {
      print("Suggestion: wear a warm coat")
    }
    else
    {
      print("Suggestion: wear whatever you want")
    }
  
  }


# tests that the function works - Expected Output (for temperature = 23): "Suggestion: wear a light jacket"
clothing_advice(23)





###Pernille comments:
  # Hint: Use if-else statements to check the temperature and return the advice

# Example of how the final function (when you've written it) should be used:
# advice <- clothing_advice(20)
# print(advice)
# Expected Output (for temperature = 20): "Wear a light jacket."

```

## Exercises from the book

- 0 and 5.5 are good to have done at least

## Ex. 0: Write up / copy the code found on page 69-70 in chapter 5 ROS and note whats going on at each step. The book explains it - so just go through it and discuss with your group to understand whats going on.


// this code stimulates the birth of girls out of 400 babies given the probability of a girl being born being 48.8%.   The 1 specifies that only 1 random number is being generated from this binomial distribution with 400 trials

```{r}
n_girls <- rbinom(1, 400, 0.488)
print(n_girls)
```


// this code shows how the value above is binomially distributed by stimulating binomial data 1000 times in total and then plotting it as a histogram, which because of relatively big amount of stimulations looks very much normally distributed

```{r}
n_sims <- 1000            # the times we want the later process to happen

n_girls <- rep(NA, n_sims)  # vector for now storing only NA for all 1000 stimulations made in the next line

# for loop where each value (of 1000) holds the binomial distributed variable from before 
for (s in 1:n_sims)
  {
  n_girls[s] <- rbinom(1, 400, 0.488)
  }

# plots a histogram of the process from before 1000 times
hist(n_girls)

# - this also shows the uncertainty, as the histogram will look different from each run of this code, but still overall have the bell curve shape

```

// this code shows how to directly make 1000 draws from the binomial distribution

```{r}
n_girls <- rbinom(n_sims, 400, 0.488)

# more direct way of making the many draws from the binomial distribution, while taking the total number of babies born (400) and the rate of girls (48.8%)



# plots a histogram again
hist(n_girls)
```

# now accounting for twins

// this code shows how to make 1000 draws from the binomial distribution

```{r}
# this code takes a samples of the size as before of 400, where it adds that fraternal twins and identical twins can happen; specifying the probabilites for both of those possibilities as well as for the probability of a single birth

birth_type <- sample(c("fraternal twin","identical twin","single birth"),
                     size=400,
                     replace=TRUE,
                     prob=c(1/125, 1/300, 1 - 1/125 - 1/300))

# (the above) makes this sample, where the birthes are based on the probability of each of these kinds of births



girls <- rep(NA, 400)  # vector for now storing only NA for all 400 stimulations made in the next line


# for loop where each value (out of 400) holds the binomial distributed variable from before for either single birth or either kind of twin birth based. Done by i (which goes to 400) going thru the list which is combined of all kinds of births relative to their probability 

for (i in 1:400)
  {
  if (birth_type[i]=="single birth") 
    {
     girls[i] <- rbinom(1, 1, 0.488)
    }
  else if (birth_type[i]=="identical twin")
     {
     girls[i] <- 2*rbinom(1, 1, 0.495)
     }
  else if (birth_type[i]=="fraternal twin")
    {
    girls[i] <- rbinom(1, 2, 0.495)
    }
 }


girls # vector, initially just filled with up with NA, but after the for loop it's of 0s, 1s and 2s - representing the number of girls born for the 400 births



n_girls <- sum(girls)

n_girls  # this prints the value (sampled from the binomial distribution) of girls born out of 400 births taken kinds of twins in to account

```

// this code shows how to more directly make 1000 draws from the binomial distribution without looping


```{r}
girls <- ifelse(birth_type=="single birth", rbinom(400, 1, 0.488),
                ifelse(birth_type=="identical twin", 2*rbinom(400, 1, 0.495),
                       rbinom(400, 2, 0.495)))


girls


```


// this code shows how to approximate the distributions of the number of girl births out of 400 - by repeating a loop of this done 1000 times

```{r}
n_sims <- 1000        # times the distribution of the data is repeated

n_girls <- rep(NA, n_sims)       # the initial NA numbers later becoming the girl births per birth


# the following does what is previously done, but all in one for loop
    # first for loop runs 1000 times, within which another for loop is run 400 times which is the number of births for each simulation
for (s in 1:n_sims)
  {
  birth_type <- sample(c("fraternal twin","identical twin","single birth"),
                       size=400, replace=TRUE, prob=c(1/125, 1/300, 1 - 1/125 - 1/300))
  
  girls <- rep(NA, 400)
  
  for (i in 1:400)
    {
    if (birth_type[i]=="single birth")
      {
      girls[i] <- rbinom(1, 1, 0.488)
      }
    else if (birth_type[i]=="identical twin")
      {
      girls[i] <- 2*rbinom(1, 1, 0.495)
      }
    else if (birth_type[i]=="fraternal twin")
      {
      girls[i] <- rbinom(1, 2, 0.495)
      }
    }

    n_girls[s] <- sum(girls) # this then is the amount of girls per 400 births per simulation of this data (aka 1000 data points)
    
    }





# here i print the values of n_girls first AND then plots it as a histogram which shows the expected bell curve as well as it being more constant each time the code is run cause of the relatively large amount of simulations (1000)

n_girls

hist(n_girls)

```







### Ex. 5.1 Discrete probability simulation: Suppose that a basketball player has a 60% chance of making a shot, and he keeps taking shots until he misses two in a row. Also assume his shots are independent (so that each shot has 60% probability of success, no matter what happened before).
* Hint 3 and 4

#### Ex. 5.1.a) Write an R function to simulate this process.
Here's some notes to get you started: 

- We're told that the basketball player has 60% chance of making the shot
- We're told he keeps shooting until missing two in a row
- We're also told to assume that his shots are independent, all having 60% of probability of success

To simulate the process we can list the variables that we'll need to record based on what we're told: 
We need to record: 
- probability of making the shot
- number of misses in a row (we need something that can count it because we know he stops when missing 2)
- number of hits in a row (to see how many he gets)
- shots taken

Let's try and write a function:
```{r}

# Function to simulate basketball player
basketball <- function()
  {
   hits_InRow_count = list() #empties list used for counting hits in a row till 2 misses
   miss_InRow_count = list() #empties list used for counting misses in a row till 2 misses
   hits_InRow = 0
   miss_InRow = 0
   throwCount = 0
   keepGoing = TRUE
  
  
  
   while (keepGoing == TRUE)
     {
     
     throwCount = throwCount + 1
     
     hit <- rbinom(1, 1, 0.60) # while keepGoing it true a new hit/throw keeps being made. This makes one variable each time which can either be 1 or 0 - aka true or false, where true is for a hit, which has a 60% possibility
     
     
     
     
     
     # logs for hits and for misses
     if(hit == TRUE)
       {
        miss_InRow_count <- append(miss_InRow_count, miss_InRow) # logs the count of misses in a row
        
        miss_InRow = 0
        hits_InRow = hits_InRow + 1
       }
     else if(hit == FALSE)
       {
        hits_InRow_count <- append(hits_InRow_count, hits_InRow) # logs the count of hits in a row
        
        hits_InRow = 0
        miss_InRow = miss_InRow + 1
        }     

     # ends the while loop if 2 misses in a row
     if(miss_InRow == 2)
       {
        miss_InRow_count <- append(miss_InRow_count, miss_InRow) # logs the count of misses in a row
       
        keepGoing = FALSE # stops for more throws as 2 misses has occured in a row
       }     
     
     }
  
   
   
   
  # simply to make the output look more like a list from python, which is printed in a straight line
  hits_InRow_count <- paste(hits_InRow_count, collapse = ", ")
  
  # return a list of the different number of hits in a row the player has had
  return(hits_InRow_count)
   
   
   
  # return a list of the different number of misses in a row the player has had
    #- e.g. to check that the function stops running when there has been 2 misses in a row
  #return(miss_InRow_count)

}


basketball()





###Pernille comments:


# Example usage of the function, when done
# basket_sim <- basketball(printing = TRUE)

```

#### Ex. 5.1.b) Put the R function in a loop to simulate the process 1000 times. Use the simulation to estimate the mean and standard deviation of the total number of shots that the player will take, and plot a histogram representing the distribution of this random variable. 
```{r}

# Function to simulate basketball player
   # altered so it now returns a string (updated per use) with the number of hits for each run of the function till 2 misses come in a row

basketball_slightlyAltered <- function(throwCountAcross)
  {
   hits_InRow_count = list() #empties list used for counting hits in a row till 2 misses
   miss_InRow_count = list() #empties list used for counting misses in a row till 2 misses
   hits_InRow = 0
   miss_InRow = 0
   throwCount = 0
   keepGoing = TRUE
  
  
  
   while (keepGoing == TRUE)
     {
     
     throwCount = throwCount + 1
     
     hit <- rbinom(1, 1, 0.60) # while keepGoing it true a new hit/throw keeps being made. This makes one variable each time which can either be 1 or 0 - aka true or false, where true is for a hit, which has a 60% possibility
     
     
     
     
     
     # logs for hits and for misses
     if(hit == TRUE)
       {
        miss_InRow_count <- append(miss_InRow_count, miss_InRow) # logs the count of misses in a row
        
        miss_InRow = 0
        hits_InRow = hits_InRow + 1
       }
     else if(hit == FALSE)
       {
        hits_InRow_count <- append(hits_InRow_count, hits_InRow) # logs the count of hits in a row
        
        hits_InRow = 0
        miss_InRow = miss_InRow + 1
        }     

     # ends the while loop if 2 misses in a row
     if(miss_InRow == 2)
       {
        miss_InRow_count <- append(miss_InRow_count, miss_InRow) # logs the count of misses in a row
       
        keepGoing = FALSE # stops for more throws as 2 misses has occured in a row
       }     
     
     }
  
   
   
   
  # simply to make the output look more like a list from python, which is printed in a straight line
  hits_InRow_count <- paste(hits_InRow_count, collapse = ", ")
  
  #print(hits_InRow_count) #prints a list of the different number of hits in a row the player has had
  

  
  throwCountAcross <- append(throwCountAcross, throwCount)
  
  # return the number of hits before 2 misses come in a row
  return(throwCountAcross)
   

}

# empties the lists before the function
throwCountAcross <- list()


# this for loop runs the function 1000 times, adding the total amount of throws for each simulation till 2 misses came in a row to a list
for (i in 1:1000)
{
  throwCountAcross <- basketball_slightlyAltered(throwCountAcross)
}

class(throwCountAcross)

#prints a list of the amount of throws per simulations
print(paste(unlist(throwCountAcross), collapse = ", ")) # unlist() converts the list to a vector, which is then made a string by paste(), but that only holds for this line - after which it still a list, the class isn't changed


throwCountAcross <- unlist(throwCountAcross) # makes the list a numeric vector


# -----------

## how to estimate the mean and sd of the total number of shots a player will take

meanThrows_basketball <- mean(throwCountAcross)

sdThrows_basketball <- sd(throwCountAcross)



## histogram representing the distribution of this random variable of shots per simulation

hist(throwCountAcross)


```






#### Ex. 5.1.c) Using your simulations, make a scatterplot of the number of shots the player will take and the proportion of shots that are successes.
```{r}

**wait on solution**





```

### Ex. 5.3: Binomial distribution: A player takes 10 basketball shots, with a 40% probability of making each shot. Assume the outcomes of the shots are independent.
#### Ex. 5.3.a) Write a line of R code to compute the probability that the player makes exactly 3 of the 10 shots.
```{r}

# the function takes the following parameters: observation, size/number of trials && the probabilit of success (of the observation of parameter 1) for each trial

dbinom(3, 10, 0.4) # 3 = number of successes;  10 = number of trials;   0.4 = probabilty of success on each trial (as they are independent of each other)





```

#### Ex. 5.3.b) Write an R function to simulate the 10 shots. Loop this function 10 000 times and check that your simulated probability of making exactly 3 shots is close to the exact probability computed in (a).
```{r}

## exact probability computed in (a)
dbinom(3, 10, 0.4)

# -- - - - - 


# empties the lists before the function
shots_success <- list()


# Function to simulating 10 shots
shots10 <- function()
  {
   
   shot <- rbinom(3, 10, 0.4)
   shots_success <- append(shots_success, shot) # logs the success of a shot
  
   return(shots_success)
  
  }
  

# looping the function 10 000 times

for (i in 1:10000)
{
  shotsSimulation <- append(shotsSimulation, shots10())
}




# calculates tje simulated probability of making exactly 3 shots

count <- sum(shotsSimulation == 1)


# calculates the probability
probSimulation <- count / length(shotsSimulation)

# print the result
probSimulation








```

## Ex. 5.4: Demonstration of the Central Limit Theorem: Let x = x1 + · · · + x20, the sum of 20 independent uniform(0, 1) random variables. In R, create 1000 simulations of x and plot their histogram. What is the normal approximation to this distribution provided by the Central Limit Theorem? Overlay a graph of the normal density on top of the histogram. Comment on any differences between the histogram and the curve.

(Recall the Central limit theorem (CLT) on the bottom of page 51 and from Methods 1)
```{r}
# your code here
```

## Ex. 5.5: Distribution of averages and differences: The heights of men in the United States are approximately normally distributed with mean 69.1 inches and standard deviation 2.9 inches. The heights of women are approximately normally distributed with mean 63.7 inches and standard deviation 2.7 inches. Let x be the average height of 100 randomly sampled men, and y be the average height of 100 randomly sampled women. In R, create 1000 simulations of x − y and plot their histogram. Using the simulations, compute the mean and standard deviation of the distribution of x − y and compare to their exact values.
*Hint 1

```{r}
# your code here
```

## Ex. 5.8: Coverage of confidence intervals: On page 15 there is a discussion of an experimental study of an education-related intervention in Jamaica, in which the point estimate of the treatment effect, on the log scale, was 0.35 with a standard error of 0.17. Suppose the true effect is 0.10 — this seems more realistic than the point estimate of 0.35 — so that the treatment on average would increase earnings by 0.10 on the log scale. Use simulation to study the statistical properties of this experiment, assuming the standard error is 0.17.
*Hint 2

```{r}
# your code here
```

#### Ex. 5.8.a) Simulate 1000 independent replications of the experiment assuming that the point estimate is normally distributed with mean 0.10 and standard deviation 0.17.
(In the experiment on page 15, we see n = 127 children)
```{r}
# your code here
```

#### Ex. 5.8.b) For each replication, compute the 95% confidence interval. Check how many of these intervals include the true parameter value.
```{r}
# your code here
```

#### Ex. 5.9: Coverage of confidence intervals after selection on statistical significance: Take your 1000 simulations from Exercise 5.8, and select just the ones where the estimate is statistically significantly different from zero. Compute the average and standard deviation of the selected point estimates. Compare these to the result from Exercise 5.8.
```{r}
# your code here
```

# Hints
### Hint 1 (for 5.5)
If you get that far, use that 
$$
\rho_{X, Y}=\operatorname{corr}(X, Y)=\frac{\operatorname{cov}(X, Y)}{\sigma_X \sigma_Y}
$$
### Hint 2 (for 5.8)
If you are stuck figuring out how to find confidence intervals in R have a look here:
https://www.geeksforgeeks.org/how-to-find-confidence-intervals-in-r/

### Hints for 5.1:
Hint 3: Think about what distribution we'll use to simulate from when it's a basketball hit we're talking about here (success/fail type outcome). Rhymes with minomial.
Hint 4: Think about the two loops we have learnt about. When this guy keeps shooting UNTIL something happens (i.e. while something is true), what loop should we use?

# Extra exercises to practice making functions in R + discussing questions

### Prime number checker
A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function should take one argument, which is the number to check, and return TRUE if the number is prime and FALSE otherwise.

#### Ex. 1: Write a function in R that checks whether a given number is a prime number
```{r}
# Function to check if a number is prime
is_prime <- function(number) {
  # Your code here
  # Hint: You may use a while-loop or a for-loop to test divisibility
  # Remember to handle edge cases like numbers less than 2
}

# Example usage:
# result <- is_prime(29)
# print(result)
# Expected Output (for number = 29): TRUE
```

### Fibonacci
The Fibonacci sequence is a series of numbers where the next number is found by adding up the two numbers before it. The sequence commonly starts with 0 and 1. The function should take one argument, n, which represents the length of the sequence to generate.

#### Ex. 2: Fibonacci Sequence Generator: Write a function in R that generates the Fibonacci sequence up to the n-th term.
```{r}
# Function to generate Fibonacci sequence
generate_fibonacci <- function(n) {
  # Your code here
  # Hint: Initialize the sequence with the first two numbers, then use a for-loop to generate the rest
}

# Example usage:
# fibonacci_sequence <- generate_fibonacci(10)
# print(fibonacci_sequence)
# Expected Output (for n = 10): 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
```

## Discuss question 1: Consider the study of ovulation and political attitudes on pp. 62-63. Why is this study flawed. Discuss with your neighbor :)

## Discuss question 2: What are the authors 3 suggestions to avoid over-interpretation of noise?

## Optional: If you want more exercises from chapter 4 try 4.1 and 4.2 Hint: In 4.2 use the proportions 50/50 or those given in the example in section "Standard error for a comparison" on pp. 52-53
